# 策略 + 适配器 + 单例，实现发券逻辑的扩展性和维护性改造（总共三个版本，迭代看）
:::success
![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737022345430-00fc2d0b-64e6-45de-a791-61b540d93be2.png)

:::

[example1.rar](https://www.yuque.com/attachments/yuque/0/2025/rar/40684821/1737082878711-76db1a5e-fcb7-4fda-999d-018487751fa3.rar)

:::success
总结：这个例子比起之前的，好处主要是

1. 这里具体业务类，并没有提供统一的接口实现，比如`WaimaiService`、`FoodService`，实际可能有自己实现的接口或者是继承，并没有实现统一的策略类![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082197551-8a370494-165f-4baa-8da1-99e7fb34a692.png)  
   _**这三个业务Service，未必有统一的接口，比如如后续的issue接口，能够复用上转型进行统一回调。**_
2. _**由1，考虑需要用Adapter适配器模式，来统一接口-》其实要说改原来业务也不是不行， 比如让三个Service再去实现Strategy接口，然后issue方法，然后分别封装具体的业务逻辑（请求 + 调用）**_
3. _**但是2这个方法，相对来说，需要修改原先封装好的内容-》不推荐**_
4. _**考虑用适配器，通过组合的方式**_![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082404192-a0bc2b7f-db9e-45b3-a396-90fb595e760c.png)_**  
   **__**组合业务对象，实现Strategy接口（复用回调），封装业务逻辑。  
   **__**-》实现了不修改Service代码基础上，实现接口的统一化，后续回调，用**_`_**issue**_`_**即可**_
5. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082502969-83cd4918-2005-4b8c-905d-011d2875da00.png)  
   level1的使用已经很简洁了，问题有2：
1. 策略实现类 Hotel Food 是无状态，类似web应用的业务方法，实际可以用单例对象，这里get每次都获取新的，性能损耗
2. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082575921-881527aa-e4a9-49c2-8abb-369eac667ba3.png)  
   获取策略对象，是通过 策略类型 -> if判断 new出来的，后续扩展还需要修改（但是业务细节这里已经省去了）
6. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082635825-8fdcabdd-8b87-4229-b1f7-3082fb237bec.png)  
   抽象类，一般提供公共的，需要继承的功能方法，对于提供标准的方法（接口规范）一般用接口来定义就行。
7. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082738953-40dfce97-d04b-4043-bf60-c5914b41ab61.png)饿汉式，static类初始化时 new对象调用私有构造器，然后注册到map（注册表）
8. _**这里单例，实际没有通过**_`_**getInstance**_`_**获取过对象，而是静态初始化的时候，已经放入注册表，后续从map里面获取（instance 和 map的对象是同一个）**_
9. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737082957835-e5652baa-9298-4db1-a690-2af9570d573d.png)  
   这里用map来实现 类似 spring里面的 获取策略对象的方式，还是很好的借鉴思路



我有个问题：这里三个策略类，实例化，注册到StrategyContext的map里面，但是这个类不会被销毁吗？

好像没有创建对象，这个算静态常量，应该是类加载阶段，放在Class对象里面，所以不会被销毁是吗，只要运行程序，就会创建并保存持有



:::







# 任务模式（状态流转） 状态模式 + 观察者模式（监听 + 通知）
:::success
1. _**任务模块要做的东西：状态  + 行为 + 行为的切换（状态流转）  即在不同的状态 不同的行为 会走到不同的状态，同时进行消息通知  和  任务管理器移除任务id**_
2. _**使用枚举类 实现任务状态 和 行为类型 的枚举，然后状态切换的任务类**_`_**Task**_`_**在不同状态 根据行为的不同，切换到不同状态**_
3. _**问题：这里状态切换if判断层数太深，不好扩展；  第二是只有**_`_**ONGOING**_`_**状态需要通知，其他状态依赖**_`_**Activity Service**_`_**以及**_`_**TaskManager**_`_**不太符合单一职责**__**<font style="color:#DF2A3F;">（应该说不太符合高内聚，即需要这个功能的持有依赖，不需要的不持有依赖）</font>**_![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737094980844-0968179b-48fa-44c2-965a-de48bbac2c87.png)
4. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095390336-3d67eda9-bcf3-4c13-8c1a-1902943f4096.png)
5. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095472848-1b9cc5e8-bb3d-4fde-8490-eb3f54456bf6.png)  
   我的理解：结合状态模式定义“把复杂逻辑判断，提取到不同状态对象”-》指的是把外层的if判断，即判断当前状态的逻辑，抽取成不同的状态对象。  
   状态对象 + 状态内的行为，组成了2层逻辑判断，这里相当于省掉外层对当前所处状态的判断（小优化）
6. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095587142-97af96a6-a2e2-4134-be53-ed9a91efd0f8.png)![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095605953-6947366c-ae0f-407c-aee8-aa64a2f30764.png)![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095644934-5c3b4f7c-25db-4bb6-b1a2-b6265cd5a1c8.png)  
   看init 和 ongoing状态，这里通过状态类实现外层逻辑，同时保证高内聚，只有通知功能类依赖了活动和任务管理器
7. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737095799396-f2387062-41ff-411c-8204-0be94da6a229.png)  
   这个类其实是环境类（保存任务状态 + 具体状态切换 + 提供接口`updateState`）。  
   _**这个设计巧妙在，利用状态类，将行为判断逻辑封装在各个状态类（且保证高内聚），同时利用状态类对象，当前持有哪个对象，当前就在哪个状态，调用对应的update，就实现了在这个状态下的状态流转。**_
8. ![](https://cdn.nlark.com/yuque/0/2025/png/40684821/1737096908070-6412c1f7-0a6e-4c45-a782-a738b6f2a476.png)  
   观察者模式的修改：活动服务 和 任务管理器（这两个可以当观察者类 具体类），将自己注册到抽象主题subject里面，然后当出现执行情况时，这边通知，本质上就是遍历调用。

:::

[example2.rar](https://www.yuque.com/attachments/yuque/0/2025/rar/40684821/1737099229842-c2d3ecf2-7db5-458d-ba73-09cd7de52a81.rar)









# 活动构建（建造者模式 + 装饰器）没理解例子，业务复杂多于知识






